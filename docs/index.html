<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dotenv C++ Library - Documentation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
    }

    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
    }

    header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    header p {
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .version-badge {
      display: inline-block;
      background: rgba(255,255,255,0.2);
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    nav {
      background: white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    nav ul {
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      padding: 1rem 0;
    }

    nav li {
      margin-right: 2rem;
    }

    nav a {
      color: #667eea;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s;
    }

    nav a:hover {
      color: #764ba2;
    }

    main {
      background: white;
      margin: 2rem auto;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 3rem;
    }

    section {
      margin-bottom: 3rem;
    }

    h2 {
      color: #667eea;
      font-size: 2rem;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 3px solid #667eea;
    }

    h3 {
      color: #764ba2;
      font-size: 1.5rem;
      margin: 2rem 0 1rem 0;
    }

    h4 {
      color: #555;
      font-size: 1.2rem;
      margin: 1.5rem 0 0.5rem 0;
    }

    pre {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 1.5rem;
      border-radius: 6px;
      overflow-x: auto;
      margin: 1rem 0;
      font-size: 0.9rem;
    }

    code {
      font-family: 'Courier New', monospace;
    }

    .inline-code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-size: 0.9em;
    }

    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin: 2rem 0;
    }

    .feature-card {
      background: #f8f9fa;
      padding: 1.5rem;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .feature-card h4 {
      margin-top: 0;
      color: #667eea;
    }

    .btn {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      text-decoration: none;
      font-weight: 600;
      transition: background 0.3s;
      margin-right: 1rem;
    }

    .btn:hover {
      background: #764ba2;
    }

    .btn-secondary {
      background: #6c757d;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    footer {
      background: #2d2d2d;
      color: white;
      text-align: center;
      padding: 2rem 0;
      margin-top: 3rem;
    }

    .warning {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .info {
      background: #d1ecf1;
      border-left: 4px solid #17a2b8;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .success {
      background: #d4edda;
      border-left: 4px solid #28a745;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    ul,
    ol {
      margin-left: 2rem;
      margin-bottom: 1rem;
    }

    li {
      margin-bottom: 0.5rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th,
    td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background: #667eea;
      color: white;
      font-weight: 600;
    }

    tr:hover {
      background: #f8f9fa;
    }

    .platform-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .platform-tab {
      padding: 0.5rem 1rem;
      background: #e9ecef;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }

    .platform-tab.active {
      background: #667eea;
      color: white;
    }
  </style>
</head>

<body>
  <header>
    <div class="container">
      <h1>üîê Dotenv C++ Library</h1>
      <p>A cross-platform C++ library for loading environment variables from .env files</p>
      <span class="version-badge">v2.0.0</span>
    </div>
  </header>

  <nav>
    <div class="container">
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#usage">Usage</a></li>
        <li><a href="#api">API Reference</a></li>
        <li><a href="#building">Building</a></li>
        <li><a href="#signing">Code Signing</a></li>
        <li><a href="https://github.com/atrox39/DotenvCpp">GitHub</a></li>
      </ul>
    </div>
  </nav>

  <main class="container">
    <section id="overview">
      <h2>Overview</h2>
      <p>Dotenv C++ is a lightweight, cross-platform library that allows you to load environment variables from <code>.env</code> files
        into your application. Designed for runtime DLL/shared library usage with thread-safe operations.</p>

      <div class="feature-grid">
        <div class="feature-card">
          <h4>üìÅ Simple File Format</h4>
          <p>Uses standard .env file format with key=value pairs</p>
        </div>
        <div class="feature-card">
          <h4>üî§ Quoted Values</h4>
          <p>Support for single and double quoted string values</p>
        </div>
        <div class="feature-card">
          <h4>üåê Cross-Platform</h4>
          <p>Works on Windows, Linux, and macOS systems</p>
        </div>
        <div class="feature-card">
          <h4>üì¶ Shared Library</h4>
          <p>Distributed as DLL/SO/DYLIB for easy integration</p>
        </div>
        <div class="feature-card">
          <h4>üîå Multiple APIs</h4>
          <p>C++ and C interfaces available</p>
        </div>
        <div class="feature-card">
          <h4>‚ö° Dynamic Loading</h4>
          <p>Runtime DLL loading supported</p>
        </div>
        <div class="feature-card">
          <h4>üîí Thread-Safe</h4>
          <p>Mutex-protected operations for concurrent access</p>
        </div>
        <div class="feature-card">
          <h4>‚ö†Ô∏è Error Handling</h4>
          <p>Proper error codes and messages</p>
        </div>
        <div class="feature-card">
          <h4>üí¨ Inline Comments</h4>
          <p>Support for comments after values</p>
        </div>
        <div class="feature-card">
          <h4>üîÑ Escape Sequences</h4>
          <p>Support for \n, \t, \\ escape sequences</p>
        </div>
        <div class="feature-card">
          <h4>‚úÇÔ∏è Whitespace Trimming</h4>
          <p>Automatic trimming of keys and values</p>
        </div>
        <div class="feature-card">
          <h4>üîß CMake Support</h4>
          <p>Modern CMake and Makefile build systems</p>
        </div>
      </div>
    </section>

    <section id="installation">
      <h2>Installation</h2>

      <h3>Download</h3>
      <p>Download the latest release from the <a href="https://github.com/atrox39/DotenvCpp/releases">GitHub releases
          page</a>.</p>

      <h3>Files by Platform</h3>
      <table>
        <tr>
          <th>Platform</th>
          <th>Library</th>
          <th>Import Library</th>
        </tr>
        <tr>
          <td>Windows</td>
          <td><code>dotenv.dll</code></td>
          <td><code>libdotenv.a</code></td>
        </tr>
        <tr>
          <td>Linux</td>
          <td><code>libdotenv.so</code></td>
          <td>-</td>
        </tr>
        <tr>
          <td>macOS</td>
          <td><code>libdotenv.dylib</code></td>
          <td>-</td>
        </tr>
      </table>

      <h3>Quick Setup</h3>
      <ol>
        <li>Copy the shared library to your project's library directory</li>
        <li>Copy <code>dotenv.hpp</code> to your project's include directory</li>
        <li>Link against the library in your build configuration</li>
      </ol>

      <h3>Requirements</h3>
      <ul>
        <li>C++17 compatible compiler (g++, clang++, MSVC)</li>
        <li>CMake 3.10+ or GNU Make</li>
      </ul>
    </section>

    <section id="usage">
      <h2>Usage</h2>

      <h3>1. Create a .env file</h3>
      <pre><code># .env file
DATABASE_URL=postgresql://localhost/mydb
API_KEY="your-api-key-here"
SECRET='single-quoted-value'
PORT=3000
DEBUG=true

# Inline comments
HOST=localhost # This is the server host

# Escape sequences (in double quotes)
MESSAGE="Line1\nLine2\tTabbed"

# Whitespace is trimmed
  KEY_WITH_SPACES  =  value with spaces trimmed  </code></pre>

      <h3>2. C++ API</h3>
      <p>The modern C++ API with error handling:</p>
      <pre><code>#include "dotenv.hpp"
#include &lt;iostream&gt;

int main() {
    // Load environment variables from .env
    DotenvError result = Dotenv::load(".env");
    if (result != DotenvError::Success) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; Dotenv::getLastError() &lt;&lt; std::endl;
        return 1;
    }
    
    // Get environment variables with default values
    std::string dbUrl = Dotenv::get("DATABASE_URL", "localhost");
    std::string apiKey = Dotenv::get("API_KEY");
    
    // Check if a variable exists
    if (Dotenv::has("DEBUG")) {
        std::cout &lt;&lt; "Debug mode enabled" &lt;&lt; std::endl;
    }
    
    // Get all loaded keys
    auto keys = Dotenv::getLoadedKeys();
    for (const auto&amp; key : keys) {
        std::cout &lt;&lt; "Loaded: " &lt;&lt; key &lt;&lt; std::endl;
    }
    
    // Clear all loaded variables
    Dotenv::clear();
    
    return 0;
}</code></pre>

      <h3>3. C API</h3>
      <p>For C compatibility and runtime DLL loading:</p>
      <pre><code>#include "dotenv.hpp"
#include &lt;stdio.h&gt;

int main() {
    // Load environment variables
    int result = DotenvLoad(".env");
    if (result != 0) {
        printf("Error: %s\n", DotenvGetLastError());
        return 1;
    }
    
    // Get variables with default value
    const char* port = DotenvGet("PORT", "8080");
    printf("Port: %s\n", port);
    
    // Check if variable exists
    if (DotenvHas("DEBUG")) {
        printf("Debug mode enabled\n");
    }
    
    // Check if loaded
    if (DotenvIsLoaded()) {
        printf("Environment loaded successfully\n");
    }
    
    // Clear loaded variables
    DotenvClear();
    
    return 0;
}</code></pre>

      <h3>4. Dynamic Runtime Loading (Windows)</h3>
      <p>Load the DLL at runtime without static linking:</p>
      <pre><code>#include &lt;windows.h&gt;
#include &lt;iostream&gt;

typedef int (*DotenvLoadFunc)(const char*);
typedef const char* (*DotenvGetFunc)(const char*, const char*);
typedef int (*DotenvHasFunc)(const char*);

int main() {
    // Load the DLL at runtime
    HMODULE hDll = LoadLibrary("dotenv.dll");
    if (!hDll) {
        std::cerr &lt;&lt; "Failed to load dotenv.dll" &lt;&lt; std::endl;
        return 1;
    }

    // Get function pointers
    auto loadFunc = (DotenvLoadFunc)GetProcAddress(hDll, "DotenvLoad");
    auto getFunc = (DotenvGetFunc)GetProcAddress(hDll, "DotenvGet");
    auto hasFunc = (DotenvHasFunc)GetProcAddress(hDll, "DotenvHas");
    
    if (loadFunc &amp;&amp; getFunc) {
        loadFunc(".env");
        std::cout &lt;&lt; "API Key: " &lt;&lt; getFunc("API_KEY", "") &lt;&lt; std::endl;
        
        if (hasFunc &amp;&amp; hasFunc("DEBUG")) {
            std::cout &lt;&lt; "Debug mode enabled" &lt;&lt; std::endl;
        }
    }
    
    // Clean up
    FreeLibrary(hDll);
    return 0;
}</code></pre>

      <h3>5. Dynamic Runtime Loading (Linux/macOS)</h3>
      <p>Load the shared library at runtime on Unix systems:</p>
      <pre><code>#include &lt;dlfcn.h&gt;
#include &lt;iostream&gt;

typedef int (*DotenvLoadFunc)(const char*);
typedef const char* (*DotenvGetFunc)(const char*, const char*);
typedef int (*DotenvHasFunc)(const char*);

int main() {
    // Load the shared library
    void* handle = dlopen("./libdotenv.so", RTLD_LAZY);  // Use .dylib on macOS
    if (!handle) {
        std::cerr &lt;&lt; "Failed to load library: " &lt;&lt; dlerror() &lt;&lt; std::endl;
        return 1;
    }

    // Get function pointers
    auto loadFunc = (DotenvLoadFunc)dlsym(handle, "DotenvLoad");
    auto getFunc = (DotenvGetFunc)dlsym(handle, "DotenvGet");
    auto hasFunc = (DotenvHasFunc)dlsym(handle, "DotenvHas");
    
    if (loadFunc &amp;&amp; getFunc) {
        loadFunc(".env");
        std::cout &lt;&lt; "API Key: " &lt;&lt; getFunc("API_KEY", "") &lt;&lt; std::endl;
        
        if (hasFunc &amp;&amp; hasFunc("DEBUG")) {
            std::cout &lt;&lt; "Debug mode enabled" &lt;&lt; std::endl;
        }
    }
    
    // Clean up
    dlclose(handle);
    return 0;
}</code></pre>

      <h3>.env File Format</h3>
      <div class="info">
        <strong>Supported Features:</strong>
        <ul>
          <li>Comments start with <code>#</code></li>
          <li>Key-value pairs: <code>KEY=value</code></li>
          <li>Double quoted values: <code>KEY="value with spaces"</code></li>
          <li>Single quoted values: <code>KEY='value'</code></li>
          <li>Inline comments: <code>KEY=value # comment</code></li>
          <li>Escape sequences: <code>\n</code>, <code>\t</code>, <code>\\</code></li>
          <li>Whitespace trimming on keys and values</li>
          <li>Empty lines are ignored</li>
        </ul>
      </div>

      <pre><code># Database Configuration
DATABASE_URL=postgresql://localhost:5432/mydb
DB_USER=admin
DB_PASSWORD="secure_password_123"

# API Settings
API_KEY="sk-1234567890abcdef"
API_ENDPOINT=https://api.example.com

# Application Settings
PORT=3000
DEBUG=true
LOG_LEVEL=info

# Escape sequences example
MULTILINE="Line 1\nLine 2\nLine 3"</code></pre>
    </section>

    <section id="api">
      <h2>API Reference</h2>

      <h3>C++ API (Dotenv class)</h3>

      <h4>Dotenv::load()</h4>
      <pre><code>static DotenvError Dotenv::load(const std::string&amp; filename = ".env");
static DotenvError Dotenv::load(const std::string&amp; filename, const DotenvOptions&amp; options);</code></pre>
      <p><strong>Description:</strong> Loads environment variables from the specified file.</p>
      <table>
        <tr>
          <th>Parameter</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>filename</td>
          <td>const std::string&amp;</td>
          <td>Path to the .env file (default: ".env")</td>
        </tr>
        <tr>
          <td>options</td>
          <td>const DotenvOptions&amp;</td>
          <td>Optional configuration for loading behavior</td>
        </tr>
      </table>
      <p><strong>Returns:</strong> <code>DotenvError</code> enum value indicating success or failure.</p>

      <h4>Dotenv::get()</h4>
      <pre><code>static std::string Dotenv::get(const std::string&amp; key, const std::string&amp; defaultValue = "");</code></pre>
      <p><strong>Description:</strong> Retrieves the value of an environment variable.</p>
      <table>
        <tr>
          <th>Parameter</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>key</td>
          <td>const std::string&amp;</td>
          <td>The name of the environment variable</td>
        </tr>
        <tr>
          <td>defaultValue</td>
          <td>const std::string&amp;</td>
          <td>Value to return if variable doesn't exist (default: "")</td>
        </tr>
      </table>
      <p><strong>Returns:</strong> The value of the variable or the default value.</p>

      <h4>Dotenv::has()</h4>
      <pre><code>static bool Dotenv::has(const std::string&amp; key);</code></pre>
      <p><strong>Description:</strong> Checks if an environment variable exists.</p>
      <p><strong>Returns:</strong> <code>true</code> if the variable exists, <code>false</code> otherwise.</p>

      <h4>Dotenv::getLoadedKeys()</h4>
      <pre><code>static std::vector&lt;std::string&gt; Dotenv::getLoadedKeys();</code></pre>
      <p><strong>Description:</strong> Returns a list of all keys that were loaded from the .env file.</p>
      <p><strong>Returns:</strong> Vector of key names.</p>

      <h4>Dotenv::clear()</h4>
      <pre><code>static void Dotenv::clear();</code></pre>
      <p><strong>Description:</strong> Clears all environment variables that were loaded by the library.</p>

      <h4>Dotenv::isLoaded()</h4>
      <pre><code>static bool Dotenv::isLoaded();</code></pre>
      <p><strong>Description:</strong> Checks if any .env file has been successfully loaded.</p>
      <p><strong>Returns:</strong> <code>true</code> if loaded, <code>false</code> otherwise.</p>

      <h4>Dotenv::getLastError()</h4>
      <pre><code>static std::string Dotenv::getLastError();</code></pre>
      <p><strong>Description:</strong> Gets the error message from the last operation.</p>
      <p><strong>Returns:</strong> Error message string.</p>

      <h3>DotenvOptions Structure</h3>
      <pre><code>struct DotenvOptions {
    bool overwrite = true;       // Overwrite existing env vars
    bool interpolate = false;    // Interpolate variables ${VAR}
    bool stripQuotes = true;     // Strip quotes from values
    bool trimWhitespace = true;  // Trim whitespace from keys and values
};</code></pre>

      <h3>Error Codes (DotenvError)</h3>
      <table>
        <tr>
          <th>Code</th>
          <th>Value</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><code>Success</code></td>
          <td>0</td>
          <td>Operation completed successfully</td>
        </tr>
        <tr>
          <td><code>FileNotFound</code></td>
          <td>1</td>
          <td>Could not open the specified file</td>
        </tr>
        <tr>
          <td><code>ParseError</code></td>
          <td>2</td>
          <td>Error parsing the file contents</td>
        </tr>
        <tr>
          <td><code>InvalidKey</code></td>
          <td>3</td>
          <td>Invalid key format encountered</td>
        </tr>
      </table>

      <h3>C API Functions</h3>

      <div class="info">
        <strong>Note:</strong> String pointers returned by <code>DotenvGet</code> and <code>DotenvGetLastError</code>
        are valid until the next call to the same function. Copy the string immediately if you need to preserve the value.
      </div>

      <h4>DotenvLoad()</h4>
      <pre><code>int DotenvLoad(const char* filename);</code></pre>
      <p><strong>Description:</strong> Loads environment variables from the specified file.</p>
      <p><strong>Returns:</strong> 0 on success, error code on failure.</p>

      <h4>DotenvGet()</h4>
      <pre><code>const char* DotenvGet(const char* key, const char* defaultValue);</code></pre>
      <p><strong>Description:</strong> Retrieves the value of an environment variable.</p>
      <p><strong>Returns:</strong> Pointer to the value string or default value.</p>

      <h4>DotenvHas()</h4>
      <pre><code>int DotenvHas(const char* key);</code></pre>
      <p><strong>Description:</strong> Checks if an environment variable exists.</p>
      <p><strong>Returns:</strong> 1 if exists, 0 otherwise.</p>

      <h4>DotenvClear()</h4>
      <pre><code>void DotenvClear(void);</code></pre>
      <p><strong>Description:</strong> Clears all loaded environment variables.</p>

      <h4>DotenvIsLoaded()</h4>
      <pre><code>int DotenvIsLoaded(void);</code></pre>
      <p><strong>Description:</strong> Checks if the library has loaded any file.</p>
      <p><strong>Returns:</strong> 1 if loaded, 0 otherwise.</p>

      <h4>DotenvGetLastError()</h4>
      <pre><code>const char* DotenvGetLastError(void);</code></pre>
      <p><strong>Description:</strong> Gets the last error message.</p>
      <p><strong>Returns:</strong> Pointer to error message string.</p>

      <h4>CallDotenvLoad() (Legacy)</h4>
      <pre><code>void CallDotenvLoad(const char* filename_c_str);</code></pre>
      <p><strong>Description:</strong> Legacy function for backwards compatibility. Use <code>DotenvLoad</code> instead.</p>

      <h3>C API Summary Table</h3>
      <table>
        <tr>
          <th>Function</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><code>DotenvLoad(filename)</code></td>
          <td>Load variables, returns 0 on success</td>
        </tr>
        <tr>
          <td><code>DotenvGet(key, default)</code></td>
          <td>Get variable value</td>
        </tr>
        <tr>
          <td><code>DotenvHas(key)</code></td>
          <td>Returns 1 if exists, 0 otherwise</td>
        </tr>
        <tr>
          <td><code>DotenvClear()</code></td>
          <td>Clear all loaded variables</td>
        </tr>
        <tr>
          <td><code>DotenvIsLoaded()</code></td>
          <td>Returns 1 if loaded, 0 otherwise</td>
        </tr>
        <tr>
          <td><code>DotenvGetLastError()</code></td>
          <td>Get last error message</td>
        </tr>
        <tr>
          <td><code>CallDotenvLoad(filename)</code></td>
          <td>Legacy function (backward compatible)</td>
        </tr>
      </table>
    </section>

    <section id="building">
      <h2>Building from Source</h2>

      <h3>Requirements</h3>
      <ul>
        <li>C++17 compatible compiler (g++, clang++, MSVC)</li>
        <li>CMake 3.10+ or GNU Make</li>
        <li>Windows SDK (for code signing on Windows)</li>
      </ul>

      <h3>Build with CMake (Recommended)</h3>
      <pre><code># Create build directory
mkdir build &amp;&amp; cd build

# Configure
cmake ..

# Build
cmake --build .

# Run tests
ctest --output-on-failure</code></pre>

      <h3>Build with Make</h3>

      <h4>Build the Library</h4>
      <pre><code># Build the library (auto-detects platform)
make

# Or explicitly
make lib</code></pre>

      <h4>Run Tests</h4>
      <pre><code>make test</code></pre>

      <h4>Clean Build Artifacts</h4>
      <pre><code>make clean</code></pre>

      <h4>Install (Unix Systems)</h4>
      <pre><code>sudo make install

# Or with custom prefix
sudo make install PREFIX=/usr/local</code></pre>

      <h3>Compiler Flags</h3>
      <p>The library is built with the following flags:</p>
      <ul>
        <li><code>-std=c++17</code> - C++17 standard</li>
        <li><code>-O2</code> - Optimization level 2</li>
        <li><code>-Wall -Wextra</code> - All warnings enabled</li>
        <li><code>-DBUILDING_DOTENV_DLL</code> - Export symbols for DLL</li>
        <li><code>-fPIC</code> - Position independent code (Unix)</li>
        <li><code>-fvisibility=hidden</code> - Hidden visibility by default (Unix)</li>
        <li><code>-static-libgcc -static-libstdc++</code> - Static linking of runtime (Windows)</li>
      </ul>

      <h3>Output Files by Platform</h3>
      <table>
        <tr>
          <th>Platform</th>
          <th>Library</th>
          <th>Object File</th>
        </tr>
        <tr>
          <td>Windows</td>
          <td><code>bin/dotenv.dll</code>, <code>bin/libdotenv.a</code></td>
          <td><code>bin/dotenv.o</code></td>
        </tr>
        <tr>
          <td>Linux</td>
          <td><code>bin/libdotenv.so</code></td>
          <td><code>bin/dotenv.o</code></td>
        </tr>
        <tr>
          <td>macOS</td>
          <td><code>bin/libdotenv.dylib</code></td>
          <td><code>bin/dotenv.o</code></td>
        </tr>
      </table>
    </section>

    <section id="signing">
      <h2>Code Signing (Windows)</h2>

      <p>For production deployments, you can sign the DLL to verify its authenticity.</p>

      <h3>Create Test Certificate</h3>
      <p>For testing purposes, create a self-signed certificate:</p>
      <pre><code>powershell -ExecutionPolicy Bypass -File create-cert.ps1</code></pre>

      <div class="warning">
        <strong>‚ö†Ô∏è Warning:</strong> Self-signed certificates will trigger security warnings. For production use, obtain
        a certificate from a trusted Certificate Authority (CA).
      </div>

      <h3>Sign the DLL</h3>
      <pre><code>make sign</code></pre>

      <p>This uses the default certificate (<code>certificate.pfx</code>) with password <code>dotenv123</code>.</p>

      <h3>Custom Certificate</h3>
      <p>To use a different certificate:</p>
      <pre><code>make sign CERT_FILE=path/to/cert.pfx CERT_PASSWORD=yourpassword</code></pre>

      <h3>Production Certificates</h3>
      <p>For production use, purchase a code signing certificate from:</p>
      <ul>
        <li><a href="https://www.digicert.com">DigiCert</a></li>
        <li><a href="https://sectigo.com">Sectigo</a></li>
        <li><a href="https://www.globalsign.com">GlobalSign</a></li>
      </ul>
    </section>

    <section id="examples">
      <h2>Examples</h2>

      <h3>Web Server Configuration</h3>
      <pre><code>#include "dotenv.hpp"
#include &lt;iostream&gt;

int main() {
    // Load with error handling
    DotenvError result = Dotenv::load(".env");
    if (result != DotenvError::Success) {
        std::cerr &lt;&lt; "Failed to load .env: " &lt;&lt; Dotenv::getLastError() &lt;&lt; std::endl;
        return 1;
    }
    
    // Get configuration with defaults
    std::string host = Dotenv::get("SERVER_HOST", "localhost");
    std::string port = Dotenv::get("SERVER_PORT", "8080");
    
    std::cout &lt;&lt; "Starting server on " &lt;&lt; host &lt;&lt; ":" &lt;&lt; port &lt;&lt; std::endl;
    
    // Check debug mode
    if (Dotenv::has("DEBUG") &amp;&amp; Dotenv::get("DEBUG") == "true") {
        std::cout &lt;&lt; "Debug mode enabled" &lt;&lt; std::endl;
    }
    
    return 0;
}</code></pre>

      <h3>Database Connection</h3>
      <pre><code>#include "dotenv.hpp"
#include &lt;iostream&gt;

class Database {
public:
    static bool connect() {
        if (Dotenv::load(".env") != DotenvError::Success) {
            std::cerr &lt;&lt; "Failed to load configuration" &lt;&lt; std::endl;
            return false;
        }
        
        // Check required variables
        if (!Dotenv::has("DATABASE_URL") || 
            !Dotenv::has("DB_USER") || 
            !Dotenv::has("DB_PASSWORD")) {
            std::cerr &lt;&lt; "Missing database credentials" &lt;&lt; std::endl;
            return false;
        }
        
        std::string url = Dotenv::get("DATABASE_URL");
        std::string user = Dotenv::get("DB_USER");
        std::string pass = Dotenv::get("DB_PASSWORD");
        
        std::cout &lt;&lt; "Connecting to database..." &lt;&lt; std::endl;
        // Your database connection code here
        
        return true;
    }
};

int main() {
    if (!Database::connect()) {
        return 1;
    }
    return 0;
}</code></pre>

      <h3>List All Loaded Variables</h3>
      <pre><code>#include "dotenv.hpp"
#include &lt;iostream&gt;

int main() {
    Dotenv::load(".env");
    
    std::cout &lt;&lt; "Loaded environment variables:" &lt;&lt; std::endl;
    for (const auto&amp; key : Dotenv::getLoadedKeys()) {
        std::cout &lt;&lt; "  " &lt;&lt; key &lt;&lt; "=" &lt;&lt; Dotenv::get(key) &lt;&lt; std::endl;
    }
    
    return 0;
}</code></pre>

      <h3>C API with Runtime Loading</h3>
      <pre><code>#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;  // Use windows.h on Windows

typedef int (*DotenvLoadFunc)(const char*);
typedef const char* (*DotenvGetFunc)(const char*, const char*);
typedef int (*DotenvHasFunc)(const char*);
typedef void (*DotenvClearFunc)(void);

int main() {
    void* lib = dlopen("./libdotenv.so", RTLD_LAZY);
    if (!lib) {
        printf("Failed to load library\n");
        return 1;
    }
    
    // Get function pointers
    DotenvLoadFunc load = dlsym(lib, "DotenvLoad");
    DotenvGetFunc get = dlsym(lib, "DotenvGet");
    DotenvHasFunc has = dlsym(lib, "DotenvHas");
    DotenvClearFunc clear = dlsym(lib, "DotenvClear");
    
    // Use the library
    if (load(".env") == 0) {
        printf("Database: %s\n", get("DATABASE_URL", "not set"));
        
        if (has("API_KEY")) {
            printf("API Key is configured\n");
        }
    }
    
    // Cleanup
    clear();
    dlclose(lib);
    
    return 0;
}</code></pre>

      <h3>C# (.NET) P/Invoke Example</h3>
      <p>Use the library from .NET applications via P/Invoke:</p>
      <pre><code>using System;
using System.Runtime.InteropServices;

class DotenvExample
{
    // Modern C API - Recommended
    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int DotenvLoad(string filename);

    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr DotenvGet(string key, string defaultValue);

    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int DotenvHas(string key);

    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern void DotenvClear();

    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int DotenvIsLoaded();

    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr DotenvGetLastError();

    // Legacy function (for backwards compatibility)
    [DllImport("dotenv.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern void CallDotenvLoad(string filename);

    public static void Main()
    {
        // Load environment variables from .env file
        int result = DotenvLoad(".env");
        if (result != 0)
        {
            IntPtr errorPtr = DotenvGetLastError();
            string error = errorPtr != IntPtr.Zero 
                ? Marshal.PtrToStringAnsi(errorPtr) 
                : "Unknown error";
            Console.WriteLine("Error loading .env: {0}", error);
            return;
        }

        // Check if loaded successfully
        if (DotenvIsLoaded() == 1)
        {
            Console.WriteLine("Environment variables loaded successfully!");
        }

        // Get environment variable with default value
        IntPtr valuePtr = DotenvGet("CONNECTION_STRING", "default_connection");
        string connectionString = Marshal.PtrToStringAnsi(valuePtr);
        Console.WriteLine("Connection string: {0}", connectionString);

        // Check if a variable exists
        if (DotenvHas("API_KEY") == 1)
        {
            IntPtr apiKeyPtr = DotenvGet("API_KEY", "");
            string apiKey = Marshal.PtrToStringAnsi(apiKeyPtr);
            Console.WriteLine("API Key: {0}", apiKey);
        }

        // You can also use standard .NET methods after loading
        string dbUrl = Environment.GetEnvironmentVariable("DATABASE_URL");
        Console.WriteLine("Database URL from Environment: {0}", dbUrl);

        // Clear loaded variables when done
        DotenvClear();
    }
}</code></pre>
      <div class="info">
        <strong>Platform Note:</strong> On Linux, use <code>libdotenv.so</code> instead of <code>dotenv.dll</code>. 
        On macOS, use <code>libdotenv.dylib</code>.
      </div>
    </section>

    <section id="troubleshooting">
      <h2>Troubleshooting</h2>

      <h3>DLL/Shared Library Not Found</h3>
      <p>If you get an error that the library cannot be loaded:</p>
      <ul>
        <li><strong>Windows:</strong> Ensure <code>dotenv.dll</code> is in the same directory as your executable or in the system PATH</li>
        <li><strong>Linux:</strong> Use <code>LD_LIBRARY_PATH</code> or install to a standard location</li>
        <li><strong>macOS:</strong> Use <code>DYLD_LIBRARY_PATH</code> or use <code>@rpath</code></li>
        <li>Use an absolute path when calling <code>LoadLibrary()</code> or <code>dlopen()</code></li>
      </ul>

      <h3>Linking Errors</h3>
      <p>If you get linking errors:</p>
      <ul>
        <li>Make sure you're linking against the correct library for your platform</li>
        <li>Verify the library is in your linker's search path</li>
        <li>Check that <code>BUILDING_DOTENV_DLL</code> is NOT defined when building your application</li>
        <li>On Windows, link against <code>libdotenv.a</code> (import library)</li>
      </ul>

      <h3>Environment Variables Not Loading</h3>
      <ul>
        <li>Verify the .env file path is correct (use absolute paths if needed)</li>
        <li>Check file permissions</li>
        <li>Ensure the file format is correct (key=value pairs)</li>
        <li>Check <code>Dotenv::getLastError()</code> for error messages</li>
        <li>Verify the return value of <code>DotenvLoad()</code> or <code>Dotenv::load()</code></li>
      </ul>

      <h3>Thread Safety Issues</h3>
      <ul>
        <li>All library functions are thread-safe</li>
        <li>String pointers from C API are valid only until the next call to the same function</li>
        <li>Copy strings immediately if you need to preserve values across calls</li>
      </ul>

      <h3>Cross-Platform Build Issues</h3>
      <ul>
        <li>Ensure you have a C++17 compatible compiler</li>
        <li>Use CMake for the most reliable cross-platform builds</li>
        <li>The Makefile auto-detects the platform (Windows/Linux/macOS)</li>
      </ul>
    </section>

    <section id="contributing">
      <h2>Contributing</h2>
      <p>Contributions are welcome! Please feel free to submit a Pull Request.</p>
      <p>
        <a href="https://github.com/atrox39/DotenvCpp" class="btn">View on GitHub</a>
        <a href="https://github.com/atrox39/DotenvCpp/issues" class="btn btn-secondary">Report Issue</a>
      </p>
    </section>

    <section id="license">
      <h2>License</h2>
      <p>This project is licensed under the MIT License - see the <a
          href="https://github.com/atrox39/DotenvCpp/blob/master/LICENSE">LICENSE</a> file for details.</p>
    </section>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 Dotenv C++ Library. Licensed under MIT License.</p>
      <p>Made with ‚ù§Ô∏è by <a href="https://github.com/atrox39" style="color: #667eea;">atrox39</a></p>
    </div>
  </footer>
</body>

</html>